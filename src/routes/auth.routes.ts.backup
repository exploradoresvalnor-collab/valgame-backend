import { Router } from 'express';
import { z } from 'zod';
import { User } from '../models/User';
import { TokenBlacklist } from '../models/TokenBlacklist';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { sendVerificationEmail } from '../config/mailer';
import { sendPasswordResetEmail } from '../config/mailer';
import { getJWTSecret, getSecurityInfo } from '../config/security';
import BaseCharacter from '../models/BaseCharacter';
import { Consumable } from '../models/Consumable';
import { Types } from 'mongoose';
import { auth } from '../middlewares/auth';

const router = Router();

// --- ZODY SCHEMAS ---
const RegisterSchema = z.object({
  email: z.string().email(),
  username: z.string().min(3),
  password: z.string().min(6)
});

const LoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6)
});

const ResendVerificationSchema = z.object({
  email: z.string().email()
});

const ForgotPasswordSchema = z.object({
  email: z.string().email()
});

const ResetPasswordSchema = z.object({
  password: z.string().min(6)
});

// --- RUTA: POST /auth/register ---
router.post('/register', async (req, res) => {
  try {
    const { email, username, password } = RegisterSchema.parse(req.body);

    const exists = await User.findOne({
      $or: [{ email }, { username }]
    });

    if (exists) {
      return res.status(409).json({ error: 'Email o username ya existe' });
    }

    const passwordHash = await bcrypt.hash(password, 10);

    // Crear instancia del usuario
    const user = new User({ email, username, passwordHash });

    // Generar token de verificaci√≥n
    const verificationToken = crypto.randomBytes(32).toString('hex');
    user.verificationToken = verificationToken;
    user.verificationTokenExpires = new Date(Date.now() + 3600000); // 1 hora

    await user.save();
    console.log(`[REGISTER] ‚úÖ Usuario creado: ${username} (${email})`);

    // Enviar correo de verificaci√≥n
    console.log(`[REGISTER] üìß Intentando enviar correo de verificaci√≥n...`);
    try {
      await sendVerificationEmail(user.email, verificationToken);
      console.log(`[REGISTER] ‚úÖ Correo enviado exitosamente`);
    } catch (emailError: any) {
      console.error(`[REGISTER] ‚ùå ERROR al enviar correo:`, emailError.message);
      return res.status(201).json({
        message: 'Registro exitoso pero hubo un problema al enviar el correo de verificaci√≥n. Por favor, contacta al soporte.',
        warning: 'Email no enviado'
      });
    }

    return res.status(201).json({
      message: 'Registro exitoso. Por favor, revisa tu correo para verificar tu cuenta.'
    });
  } catch (e: any) {
    console.error('[REGISTER] ‚ùå Error en registro:', e.message);
    return res.status(400).json({ error: e?.message || 'Bad Request' });
  }
});

// --- RUTA: GET /auth/verify/:token ---
router.get('/verify/:token', async (req, res) => {
  try {
    const { token } = req.params;

    const user = await User.findOne({
      verificationToken: token,
      verificationTokenExpires: { $gt: new Date() }
    });

    if (!user) {
      return res.status(400).send(`
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Token Inv√°lido - Valgame</title>
  <style>
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    .card { background: white; padding: 40px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); max-width: 500px; text-align: center; }
    h1 { color: #e74c3c; font-size: 28px; margin-bottom: 20px; }
    p { color: #666; line-height: 1.6; }
    .icon { font-size: 64px; margin-bottom: 20px; }
  </style>
</head>
<body>
  <div class="card">
    <div class="icon">‚ùå</div>
    <h1>Token Inv√°lido o Expirado</h1>
    <p>El enlace de verificaci√≥n no es v√°lido o ya ha expirado.</p>
    <p>Por favor, solicita un nuevo correo de verificaci√≥n.</p>
  </div>
</body>
</html>
      `);
    }

    // Verificar usuario y limpiar tokens
    user.isVerified = true;
    user.verificationToken = undefined;
    user.verificationTokenExpires = undefined;
    await user.save();

    console.log(`[VERIFY] ‚úÖ Usuario verificado: ${user.username} (${user.email})`);

    // Entregar paquete del pionero al verificar
    try {
      const { deliverPioneerPackage } = await import('../services/onboarding.service');
      const result = await deliverPioneerPackage(user);
      if (result.delivered) {
        console.log(`[VERIFY] üéâ Paquete del Pionero entregado a ${user.username}`);
      } else {
        console.warn(`[VERIFY] ‚ö†Ô∏è No se pudo entregar paquete pionero: ${result.reason}`);
      }
      (req as any).onboardingResult = result;
    } catch (onboardingError) {
      console.error(`[VERIFY] ‚ùå Error al entregar paquete pionero:`, onboardingError);
      (req as any).onboardingResult = { delivered: false, reason: 'onboarding_error' };
    }

    // Detectar si es petici√≥n API (JSON) o browser (HTML)
    const accept = req.headers.accept || '';
    const isAPI = accept.includes('application/json') || req.query.format === 'json' || process.env.NODE_ENV === 'test';

    if (isAPI) {
      // Respuesta JSON para APIs/tests
      const apiResponse: any = {
        ok: true,
        message: 'Usuario verificado exitosamente'
      };
      const onboardingResult = (req as any).onboardingResult;
      if (onboardingResult) {
        if (onboardingResult.delivered) {
          apiResponse.rewards = onboardingResult.rewards || null;
        } else {
          apiResponse.onboarding = { delivered: false, reason: onboardingResult.reason };
        }
      }
      return res.json(apiResponse);
    } else {
      // P√°gina HTML para browsers
      return res.send(`
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>¬°Cuenta Verificada! - Valgame</title>
  <style>
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    .card { background: white; padding: 40px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); max-width: 500px; text-align: center; animation: slideIn 0.5s ease-out; }
    @keyframes slideIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    h1 { color: #27ae60; font-size: 32px; margin-bottom: 20px; }
    p { color: #666; line-height: 1.6; margin: 15px 0; }
    .icon { font-size: 80px; margin-bottom: 20px; animation: bounce 1s ease infinite; }
    @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    .rewards { background: #f0f4ff; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: left; }
    .rewards h3 { color: #667eea; margin-top: 0; }
    .rewards ul { list-style: none; padding: 0; }
    .rewards li { padding: 8px 0; border-bottom: 1px solid #e0e0e0; }
    .rewards li:last-child { border-bottom: none; }
    .btn { display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 30px; border-radius: 8px; text-decoration: none; font-weight: bold; margin-top: 20px; transition: transform 0.2s; }
    .btn:hover { transform: scale(1.05); }
  </style>
</head>
<body>
  <div class="card">
    <div class="icon">üéâ</div>
    <h1>¬°Cuenta Verificada con √âxito!</h1>
    <p>¬°Bienvenido a <strong>Valgame</strong>, aventurero <strong>${user.username}</strong>!</p>

    <div class="rewards">
      <h3>‚úÖ Tu cuenta est√° verificada</h3>
      <p>Ya puedes iniciar sesi√≥n y comenzar tu aventura.</p>
    </div>

    <p style="margin-top: 30px;">Ya puedes cerrar esta ventana e iniciar sesi√≥n en el juego.</p>
    <a href="#" class="btn">üéÆ Ir al Juego</a>
  </div>
</body>
</html>
      `);
    }
  } catch (error: any) {
    console.error('[VERIFY] ‚ùå Error en verificaci√≥n:', error.message);
    return res.status(500).send(`
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Error - Valgame</title>
  <style>
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    .card { background: white; padding: 40px; border-radius: 16px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); max-width: 500px; text-align: center; }
    h1 { color: #e74c3c; font-size: 28px; margin-bottom: 20px; }
    p { color: #666; line-height: 1.6; }
    .icon { font-size: 64px; margin-bottom: 20px; }
  </style>
</head>
<body>
  <div class="card">
    <div class="icon">‚ö†Ô∏è</div>
    <h1>Error del Servidor</h1>
    <p>Ocurri√≥ un error al procesar tu verificaci√≥n.</p>
    <p>Por favor, contacta al soporte t√©cnico.</p>
  </div>
</body>
</html>
    `);
  }
});

// --- RUTA: POST /auth/login ---
router.post('/login', async (req, res) => {
  try {
    const { email, password } = LoginSchema.parse(req.body);

    const user = await User.findOne({ email });
    if (!user) return res.status(401).json({ error: 'Credenciales inv√°lidas' });

    // Bypass de verificaci√≥n en desarrollo/test
    const bypassVerification = process.env.TEST_MODE === 'true' || process.env.NODE_ENV === 'test';
    if (!user.isVerified && !bypassVerification) {
      return res.status(403).json({ error: 'Debes verificar tu cuenta antes de iniciar sesi√≥n.' });
    }

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(401).json({ error: 'Credenciales inv√°lidas' });

    const token = jwt.sign(
      { id: user._id },
      getJWTSecret(),
      { expiresIn: '7d' }
    );

    // Token en httpOnly cookie
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000
    });

    // Preparar datos del usuario
    const userData = {
      id: user._id,
      email: user.email,
      username: user.username,
      isVerified: user.isVerified,
      tutorialCompleted: user.tutorialCompleted,
      // Recursos
      val: user.val ?? 0,
      boletos: user.boletos ?? 0,
      evo: user.evo ?? 0,
      invocaciones: user.invocaciones ?? 0,
      evoluciones: user.evoluciones ?? 0,
      boletosDiarios: user.boletosDiarios ?? 0,
      // Arrays e inventario
      personajes: user.personajes || [],
      inventarioEquipamiento: user.inventarioEquipamiento || [],
      inventarioConsumibles: user.inventarioConsumibles || [],
      // L√≠mites
      limiteInventarioEquipamiento: user.limiteInventarioEquipamiento,
      limiteInventarioConsumibles: user.limiteInventarioConsumibles,
      limiteInventarioPersonajes: user.limiteInventarioPersonajes,
      // Estado
      personajeActivoId: user.personajeActivoId,
      receivedPioneerPackage: user.receivedPioneerPackage
    };

    // En test, devolver token en body
    if (process.env.NODE_ENV === 'test') {
      return res.json({
        message: 'Login exitoso',
        token,
        user: userData
      });
    }

    // En producci√≥n/desarrollo, devolver datos completos
    return res.json({
      message: 'Login exitoso',
      user: userData
    });
  } catch (e: any) {
    return res.status(400).json({ error: e?.message || 'Bad Request' });
  }
});

// --- RUTA: POST /auth/logout ---
router.post('/logout', auth, async (req, res) => {
  try {
    const header = req.header('Authorization') || '';
    let token = header.replace(/^Bearer\s+/i, '').trim();

    // Si no hay token en header, intentar obtenerlo de la cookie
    if (!token && req.cookies?.token) {
      token = req.cookies.token;
    }

    if (!token) {
      return res.status(400).json({ error: 'No se proporcion√≥ token' });
    }

    // Decodificar token para obtener fecha de expiraci√≥n
    const decoded = jwt.verify(token, getJWTSecret()) as any;
    const expiresAt = new Date(decoded.exp * 1000);

    // Agregar token a blacklist
    await TokenBlacklist.create({
      token,
      expiresAt
    });

    // Limpiar cookie httpOnly
    res.clearCookie('token', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict'
    });

    return res.json({ message: 'Sesi√≥n cerrada correctamente' });
  } catch (error: any) {
    console.error('[LOGOUT] Error:', error);
    return res.status(500).json({ error: 'Error al cerrar sesi√≥n' });
  }
});

// --- RUTA: POST /auth/resend-verification ---
router.post('/resend-verification', async (req, res) => {
  try {
    const { email } = ResendVerificationSchema.parse(req.body);

    const user = await User.findOne({ email });
    if (!user) {
      // Por seguridad, no revelar si el usuario existe
      return res.json({ message: 'Si el correo existe y no est√° verificado, se enviar√° un nuevo email de verificaci√≥n.' });
    }

    if (user.isVerified) {
      return res.status(400).json({ error: 'La cuenta ya est√° verificada' });
    }

    // Verificar si existe token v√°lido para evitar spam
    if (user.verificationTokenExpires && user.verificationTokenExpires > new Date()) {
      const minutesLeft = Math.ceil((user.verificationTokenExpires.getTime() - Date.now()) / 60000);
      return res.status(429).json({
        error: `Ya existe un email de verificaci√≥n v√°lido. Espera ${minutesLeft} minutos antes de solicitar otro.`
      });
    }

    // Generar nuevo token
    const verificationToken = crypto.randomBytes(32).toString('hex');
    user.verificationToken = verificationToken;
    user.verificationTokenExpires = new Date(Date.now() + 3600000);
    await user.save();

    // Enviar email
    await sendVerificationEmail(user.email, verificationToken);

    return res.json({ message: 'Email de verificaci√≥n enviado. Revisa tu bandeja de entrada.' });
  } catch (e: any) {
    console.error('[RESEND-VERIFICATION] Error:', e);
    return res.status(400).json({ error: e?.message || 'Error al reenviar verificaci√≥n' });
  }
});

// --- RUTA: POST /auth/forgot-password ---
router.post('/forgot-password', async (req, res) => {
  try {
    const { email } = ForgotPasswordSchema.parse(req.body);

    const user = await User.findOne({ email });
    if (!user) {
      // Por seguridad, no revelar si el usuario existe
      return res.json({ message: 'Si el correo existe, se enviar√° un email con instrucciones para recuperar tu contrase√±a.' });
    }

    // Generar token de recuperaci√≥n
    const resetToken = crypto.randomBytes(32).toString('hex');
    user.resetPasswordToken = resetToken;
    user.resetPasswordTokenExpires = new Date(Date.now() + 3600000);
    await user.save();

    // Construir URL del frontend
    const frontendURL = process.env.FRONTEND_URL || 'http://localhost:4200';
    const resetURL = `${frontendURL}/reset-password/${resetToken}`;

    // Enviar email
    const { sendPasswordResetEmail } = await import('../config/mailer');
    await sendPasswordResetEmail(user.email, resetURL);

    return res.json({ message: 'Si el correo existe, se enviar√° un email con instrucciones para recuperar tu contrase√±a.' });
  } catch (e: any) {
    console.error('[FORGOT-PASSWORD] Error:', e);
    return res.status(400).json({ error: e?.message || 'Error al procesar solicitud' });
  }
});

// --- RUTA: GET /auth/reset-form/:token ---
router.get('/reset-form/:token', async (req, res) => {
  try {
    const { token } = req.params;

    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordTokenExpires: { $gt: new Date() }
    });

    if (!user) {
      return res.status(400).send('Token inv√°lido o expirado');
    }

    // Retornar formulario HTML
    return res.type('text/html').send(`<!DOCTYPE html>
<html>
<head><title>Reset</title></head>
<body>TEST FORM</body>
</html>`);
  } catch (e: any) {
    return res.status(500).send('Error');
  }
});

// --- RUTA: POST /auth/reset-password/:token ---
router.post('/reset-password/:token', async (req, res) => {
  try {
    const { token } = req.params;
    const { password } = ResetPasswordSchema.parse(req.body);

    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordTokenExpires: { $gt: new Date() }
    });

    if (!user) {
      return res.status(400).json({ error: 'Token de recuperaci√≥n inv√°lido o expirado' });
    }

    // Hash de la nueva contrase√±a
    const passwordHash = await bcrypt.hash(password, 10);
    user.passwordHash = passwordHash;

    // Limpiar tokens de recuperaci√≥n
    user.resetPasswordToken = undefined;
    user.resetPasswordTokenExpires = undefined;
    await user.save();

    return res.json({ message: 'Contrase√±a actualizada exitosamente. Ya puedes iniciar sesi√≥n.' });
  } catch (e: any) {
    console.error('[RESET-PASSWORD] Error:', e);
    return res.status(400).json({ error: e?.message || 'Error al resetear contrase√±a' });
  }
});

export default router;
